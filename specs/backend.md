# Backend Specification

Bun server (static files + bundling) + Convex (data) for the 2026 Planning Calendar.

---

## 1. Architecture

### Project Structure

```
calendar/
├── server.ts            # Bun.serve() dev/prod server
├── build.ts             # Production build script
├── package.json         # Dependencies and scripts
├── tsconfig.json        # TypeScript configuration
├── src/                 # React TypeScript source
│   ├── main.tsx         # Entry point with ConvexProvider
│   ├── App.tsx          # Root component
│   ├── components/      # React components
│   ├── hooks/           # Custom hooks
│   ├── lib/             # Utilities (geometry, weeks, constants)
│   └── styles.css       # Global styles
├── public/              # Static files
│   ├── index.html       # HTML entrypoint
│   ├── manifest.json    # PWA manifest
│   └── sw.js            # Service worker
├── convex/
│   ├── schema.ts        # Database schema
│   └── events.ts        # Event CRUD functions
└── dist/                # Production build output
```

### Bun Server (`server.ts`)

Development mode bundles TypeScript/React on the fly. Production mode serves pre-built files from `dist/`.

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/` | GET | Serve `index.html` |
| `/src/main.tsx` | GET | Bundle and serve React app (dev) |
| `/main.js` | GET | Serve bundled JS (prod) |
| `/styles.css` | GET | Serve CSS |
| `/manifest.json` | GET | PWA manifest |
| `/sw.js` | GET | Service worker |
| `/icon-192.png` | GET | PWA icon (192×192, generated) |
| `/icon-512.png` | GET | PWA icon (512×512, generated) |

### Dynamic Icon Generation

PWA icons are generated at runtime using raw PNG construction:
1. PNG signature: `[137, 80, 78, 71, 13, 10, 26, 10]`
2. IHDR chunk: width/height as 32-bit big-endian, bit depth 8, color type 2 (RGB)
3. IDAT chunk: Use `Bun.deflateSync()` to compress raw pixel data
4. Each chunk needs CRC32 checksum of type + data

Alternative: Include static PNG files in `public/` instead of generating at runtime.

### Development Hot Reload

The dev server caches the bundled JS for performance. File watching invalidates the cache:

```typescript
if (!isProd) {
  const watcher = require("fs").watch("./src", { recursive: true }, () => {
    cachedBundle = null;
  });
  process.on("exit", () => watcher.close());
}
```

Note: This is basic cache invalidation, not HMR. Browser refresh required after changes.

---

## 2. Data Model

### Schema

```typescript
// convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  events: defineTable({
    title: v.string(),
    week: v.union(v.number(), v.null()),
    priority: v.union(
      v.literal("major"),
      v.literal("big"),
      v.literal("medium"),
      v.literal("minor")
    ),
    description: v.optional(v.string()),
    createdAt: v.number(),
  }),
});
```

---

## 3. Convex Functions

### Queries

| Function | Args | Returns | Purpose |
|----------|------|---------|---------|
| `getEvents` | - | `Event[]` | Get all events |

### Mutations

| Function | Args | Returns | Purpose |
|----------|------|---------|---------|
| `createEvent` | `title, week, priority, description?` | `eventId` | Create event |
| `updateEvent` | `eventId, updates` | - | Update event |
| `deleteEvent` | `eventId` | - | Delete event |

---

## 4. Environment Variables

**Bun server:** `PORT` (default: 3000), `NODE_ENV` (development/production)

**Convex:** Managed via `.env.local` (auto-generated by `bunx convex dev`)
```
CONVEX_DEPLOYMENT=dev:opulent-lynx-809
CONVEX_URL=https://opulent-lynx-809.convex.cloud
```

**Frontend:** Convex URL configured in `src/main.tsx` (must match `CONVEX_URL` from `.env.local`)

---

## 5. Deployment

### Initial Setup

```bash
# 1. Install dependencies
bun install

# 2. Deploy Convex (creates .env.local with deployment URL)
bunx convex deploy

# 3. Update src/main.tsx with your Convex URL from .env.local

# 4. Build production bundle
bun run build

# 5. Deploy (e.g., to Fly.io, Railway, or any Node.js host)
# The server.ts file serves the built files in production mode
```

### Subsequent Deploys

```bash
# Deploy Convex functions (if changed)
bunx convex deploy

# Rebuild and deploy server (if frontend/server changed)
bun run build
# Deploy your preferred way
```

---

## 6. Local Development

```bash
# Terminal 1: Start Convex dev server (uses .env.local)
bunx convex dev

# Terminal 2: Start Bun dev server
bun run dev

# Open http://localhost:3000
```

Note: `bunx convex dev` reads from `.env.local`. The Convex URL in `src/main.tsx` should match `CONVEX_URL` from that file.

---

## 7. Testing

### Test Architecture

The project uses **two test runners** due to runtime requirements:

| Runner | Environment | Tests | Why |
|--------|-------------|-------|-----|
| `bun test` | Bun runtime | Server endpoints | Requires `Bun.serve()`, `Bun.build()` APIs |
| `vitest` | edge-runtime | Convex functions | Required by `convex-test` library |

### Dependencies

```json
"devDependencies": {
  "@edge-runtime/vm": "^4.0.0",
  "convex-test": "^0.0.35",
  "vitest": "^3.0.0"
}
```

### Configuration

**vitest.config.ts:**
```typescript
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    environment: "edge-runtime",
    server: { deps: { inline: ["convex-test"] } },
    include: ["convex/**/*.test.ts"],
  },
});
```

**convex/test.setup.ts:**
```typescript
export const modules = import.meta.glob("./**/!(*.*.*)*.*s");
```

### Server Testability Pattern

The server exports a `createServer()` function for testing:

```typescript
export function createServer(port: number = PORT) {
  const server = Bun.serve({ port, fetch(req) { ... } });
  return server;
}

// Only start if run directly (not imported)
if (import.meta.main) {
  const server = createServer();
  console.log(`Server running at http://localhost:${server.port}`);
}
```

Key patterns:
- `import.meta.main` is `true` only when file is the entry point
- Port 0 lets OS assign available port (avoids conflicts)
- Server object has `.port` and `.stop()` for test lifecycle

### Server Tests

**tests/server.test.ts:**
```typescript
import { describe, test, expect, beforeAll, afterAll } from "bun:test";
import { createServer } from "../server";

describe("server endpoints", () => {
  let server: ReturnType<typeof createServer>;
  let baseUrl: string;

  beforeAll(() => {
    server = createServer(0);
    baseUrl = `http://localhost:${server.port}`;
  });

  afterAll(() => {
    server.stop();
  });

  test("GET / returns HTML", async () => {
    const res = await fetch(`${baseUrl}/`);
    expect(res.status).toBe(200);
    expect(res.headers.get("content-type")).toBe("text/html");
    expect(await res.text()).toContain("<!DOCTYPE html>");
  });

  test("GET /src/main.tsx returns bundled JS", async () => {
    const res = await fetch(`${baseUrl}/src/main.tsx`);
    expect(res.status).toBe(200);
    expect(res.headers.get("content-type")).toBe("application/javascript");
  });

  test("GET /styles.css returns CSS", async () => {
    const res = await fetch(`${baseUrl}/styles.css`);
    expect(res.status).toBe(200);
    expect(res.headers.get("content-type")).toBe("text/css");
  });

  test("GET /manifest.json returns PWA manifest", async () => {
    const res = await fetch(`${baseUrl}/manifest.json`);
    expect(res.status).toBe(200);
    const json = await res.json();
    expect(json).toHaveProperty("name");
  });

  test("GET /sw.js returns service worker", async () => {
    const res = await fetch(`${baseUrl}/sw.js`);
    expect(res.status).toBe(200);
    expect(res.headers.get("content-type")).toBe("application/javascript");
  });

  test("GET /icon-192.png returns valid PNG", async () => {
    const res = await fetch(`${baseUrl}/icon-192.png`);
    expect(res.status).toBe(200);
    const bytes = new Uint8Array(await res.arrayBuffer());
    expect(bytes.slice(0, 4)).toEqual(new Uint8Array([137, 80, 78, 71]));
  });

  test("GET /icon-512.png returns valid PNG", async () => {
    const res = await fetch(`${baseUrl}/icon-512.png`);
    expect(res.status).toBe(200);
    const bytes = new Uint8Array(await res.arrayBuffer());
    expect(bytes.slice(0, 4)).toEqual(new Uint8Array([137, 80, 78, 71]));
  });

  test("GET /nonexistent returns 404", async () => {
    const res = await fetch(`${baseUrl}/nonexistent`);
    expect(res.status).toBe(404);
  });
});
```

### Convex Tests

**convex/events.test.ts:**
```typescript
import { convexTest } from "convex-test";
import { describe, test, expect } from "vitest";
import { api } from "./_generated/api";
import schema from "./schema";
import { modules } from "./test.setup";

describe("events", () => {
  test("createEvent returns ID", async () => {
    const t = convexTest(schema, modules);
    const eventId = await t.mutation(api.events.createEvent, {
      title: "Test Event",
      week: 5,
      priority: "major",
    });
    expect(eventId).toBeDefined();
  });

  test("createEvent and getEvents", async () => {
    const t = convexTest(schema, modules);
    await t.mutation(api.events.createEvent, {
      title: "Test Event",
      week: 5,
      priority: "major",
    });
    const events = await t.query(api.events.getEvents);
    expect(events).toHaveLength(1);
    expect(events[0]).toMatchObject({ title: "Test Event", week: 5 });
  });

  test("updateEvent modifies fields", async () => {
    const t = convexTest(schema, modules);
    const eventId = await t.mutation(api.events.createEvent, {
      title: "Original",
      week: 1,
      priority: "minor",
    });
    await t.mutation(api.events.updateEvent, {
      eventId,
      title: "Updated",
      priority: "major",
    });
    const events = await t.query(api.events.getEvents);
    expect(events[0]).toMatchObject({ title: "Updated", priority: "major", week: 1 });
  });

  test("deleteEvent removes event", async () => {
    const t = convexTest(schema, modules);
    const eventId = await t.mutation(api.events.createEvent, {
      title: "To Delete",
      week: null,
      priority: "medium",
    });
    expect(await t.query(api.events.getEvents)).toHaveLength(1);
    await t.mutation(api.events.deleteEvent, { eventId });
    expect(await t.query(api.events.getEvents)).toHaveLength(0);
  });
});
```

### Running Tests

```bash
bun run test          # Run all tests (Convex + Server)
bun run test:convex   # Run only Convex tests (vitest)
bun run test:server   # Run only server tests (bun test)
bun run test:watch    # Watch mode for Convex tests
```

### Lessons Learned

**Friction 1: Two test runners required**
- `convex-test` requires Vitest with edge-runtime environment
- Server tests require Bun APIs (`Bun.serve`, `Bun.build`) unavailable in edge-runtime
- Solution: Run `vitest` for Convex, `bun test` for server, combine in `test` script

**Friction 2: CONVEX_URL undefined in tests**
- `Bun.build({ define: { "process.env.CONVEX_URL": JSON.stringify(undefined) } })` throws
- Solution: Conditionally add define only when env var exists:
  ```typescript
  const define: Record<string, string> = {};
  if (process.env.CONVEX_URL) {
    define["process.env.CONVEX_URL"] = JSON.stringify(process.env.CONVEX_URL);
  }
  ```

**Friction 3: Import side effects**
- Original server started on import, breaking test isolation
- Solution: `import.meta.main` guard pattern (Bun/Deno standard)

**Friction 4: Port conflicts in parallel tests**
- Solution: Use port 0 for OS-assigned ports, read `server.port` after start

### API Testing (via Convex Dashboard)

1. Go to https://dashboard.convex.dev
2. Select your project
3. Use the "Functions" tab to test queries/mutations

### Manual Verification

```bash
# Development mode
bun run dev

# Production mode
bun run build
bun run start

# Verify static files served
curl http://localhost:3000/
curl http://localhost:3000/manifest.json
curl http://localhost:3000/sw.js
curl http://localhost:3000/icon-192.png --output /dev/null -w "%{http_code}\n"
```

---

## 8. Implementation Notes

### TypeScript Quirks

- Convex generated files (`convex/_generated/`) don't exist until first `bunx convex dev`
- Run `bunx convex codegen` to generate types without starting dev server
- Bun's Response body may need `as unknown as BodyInit` cast for Uint8Array

### Priority Type Alignment

The Convex schema uses a string union for priority. When using the value in frontend components that expect a `Priority` type, cast explicitly:

```typescript
const priority = event.priority as Priority;
```

### Convex URL Configuration

Bun auto-loads `.env.local` and exposes variables via `process.env`. Inject the Convex URL at bundle time:

**server.ts** (in `bundleApp` function):
```typescript
const result = await Bun.build({
  entrypoints: ["./src/main.tsx"],
  define: {
    "process.env.CONVEX_URL": JSON.stringify(process.env.CONVEX_URL),
  },
});
```

**src/main.tsx**:
```typescript
const convex = new ConvexReactClient(process.env.CONVEX_URL!);
```

This approach:
- Reads from `.env.local` automatically (no manual copy)
- Works in both dev and production
- Fails fast if CONVEX_URL is missing

### Build Order Dependency

TypeScript compilation depends on Convex generated files:

1. Run `bunx convex codegen` (or `bunx convex dev`) first
2. Then `bunx tsc --noEmit` will succeed
3. `convex/_generated/` is gitignored but required for builds

CI/CD pipelines must run codegen before type checking.

### Future: Authentication

Authentication is deferred to a future phase. When added:
- Add `@convex-dev/auth` tables via `authTables` spread
- Add `createdBy: v.id("users")` to events
- Add `calendars` and `memberships` tables for multi-user support
- Add auth checks to all mutations
