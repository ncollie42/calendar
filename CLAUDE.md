# Claude Code Instructions

## Spec-Driven Development

This repository treats **specs as source code** and **implementation as a compiled artifact**.

### The Philosophy

The specs in `specs/` are the source of truth—not the code. Code can be deleted and regenerated from specs. If the spec is complete and unambiguous, Claude should be able to rebuild the entire codebase from scratch.

This inverts the typical relationship:
- **Traditional**: Code is source, docs describe code
- **This repo**: Specs are source, code implements specs

### Why This Matters

1. **Specs must be complete** — If Claude can't rebuild a feature, the spec is incomplete
2. **Code is disposable** — Don't preserve code for its own sake; preserve knowledge in specs
3. **Iterate on specs** — When exploring a feature, code first, then extract learnings back to spec
4. **Determinism** — Precise specs produce consistent implementations across rebuilds

### Workflow

**Adding a new feature:**
1. Discuss requirements with user
2. Draft spec addition with precise details
3. Update the appropriate spec file
4. Implement code that matches spec exactly

**Iterating on existing features:**
1. Make changes in code to explore/prototype
2. Once satisfied, extract changes back to spec
3. Spec becomes the permanent record

**Full rebuild (periodic):**
1. Delete implementation code (keep specs)
2. Regenerate from specs
3. Verify behavior matches expectations
4. If gaps found, update specs

### Spec Files

| File | Purpose |
|------|---------|
| `specs/requirements.md` | User stories, target users, acceptance criteria |
| `specs/constants.md` | All design tokens (colors, geometry, timing) |
| `specs/data-model.md` | Database schema, types, access control |
| `specs/manifest.md` | File list, build order, component interfaces |
| `specs/frontend.md` | UI behavior, interactions, components |
| `specs/backend.md` | Server, deployment, testing, infrastructure |

**Hierarchy:**
- `requirements.md` defines **what** and **why**
- `constants.md` and `data-model.md` define **shared foundations**
- `frontend.md` and `backend.md` define **how** (behavior)
- `manifest.md` defines **structure** (files, build order, interfaces)

### Implementation Files

| Path | Purpose |
|------|---------|
| `src/` | React TypeScript source |
| `src/components/` | React components |
| `src/hooks/` | Custom hooks |
| `src/lib/` | Utilities (constants, geometry, weeks) |
| `public/` | Static files (index.html, manifest.json, sw.js) |
| `convex/` | Convex schema and functions |
| `server.ts` | Bun.serve() dev/prod server |
| `build.ts` | Production build script |

### When Implementing

- **Follow `manifest.md` build order** — Dependencies before dependents
- **Use token names from `constants.md`** — Not hardcoded values
- **Match `data-model.md` exactly** — Schema is authoritative
- **Reference `frontend.md` for behavior** — Not just what it looks like, but how it works

---

## Local Development

```bash
bun install      # Install dependencies
bunx convex dev  # Terminal 1 (Convex backend)
bun run dev      # Terminal 2 (Bun dev server)
# Open http://localhost:3000
```

### Environment

- `.env.local` — Convex deployment config (auto-generated by `bunx convex dev`)

---

## Coding Practices

### Defensive Programming

Assert aggressively. If an assumption could be wrong, assert it—inputs non-nil, values in range, invariants hold.

The goal: if your mental model is wrong, crash immediately at the violation, not later with corrupted state. When something crashes, add assertions that would have caught it earlier. The assertions are the spec.

